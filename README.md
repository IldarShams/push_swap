# push_swap
Проект школы 21, в котором требуется реализовать сортировку двух стеков данным набором операций над стеками.
Операции:
1. sa (swap A)  - первый и второй элемент меняются местами, то есть второй элемент становится вершиной стека
2. sb (swap B)  - аналогично sa.
3. ss - sa и sb одновременно, при проверке считается за одну операцию.
4. pa (push A) - добавление элемента в стек А из стека В.
5. pb (push B) - аналогично pa.
6. ra (rotate A) - вершина стека А переносится в конец стека, второй элемент стека становится вершиной.
6. rb (rotate B) - аналогично ra.
7. rr - ra и rb одновременно, при проверке считается за одну операцию.
8. rra (reverse rotate A) - последний элемент стека А становится вершиной стека, первый элемент становится вторым.
9. rrb - аналогично rrb.
10. rrr - rra и rrb одновременно, при проверке считается за одну операцию.

## Выбор алгоритма сортировки
Для успешной сдачи проекта необходимо отсортировать стек А за наименьшее число шагов.
Для 100 и 500 элементов определены границы:
#### менее 700 и 5500 - 5 баллов,
#### менее 900 и 7000 - 4 балла,
#### менее 1100 и 8500 - 3 балла,
#### менее 1300 и 9000 - 2 балла,
#### менее 1500 и 10500 - 1 балл,
соответственно.

Поэтому, чтобы сдать на максимум баллов, надо выбирать алгоритмы со сложностью log2(n) * n или быстрее.

664 = log2(100) * 100; 

4482 = log2(500) * 500

## Алгоритм быстрой сортровки

Пусть дан набор чисел, который требуется отсортировать:
#### 2, 4, -1, 5, 1, -5, -3, -2

Алгоритм быстрой сортировки заключается в том, что мы выбираем опорный элемент и делим набор на две части. В первую попадают все элементы, которые меньше опорного, а во вторую - больше опорного или равен.

Пусть опорным будет 1:
#### -1, -5, -3, -2 | 2, 4, 1

Повторяем рекурсивно для левой и правой части.

### Левая часть: -1, -5, -3, -2
Опорный -2:
#### -5, -3 | -1, -2
Левая часть отсортированна.

Сортируем правую и получаем:

#### -5, -3, -2, -1

### Правая часть: 2, 4, 1
Опорный: 2
#### 1 | 2, 4

Итак, мы получили отсортированный набор чисел:
#### -5, -3, -2, -1, 1, 2, 4

## Реализация алгоритма быстрой сортировки для двух стеков
Пусть дан набор из N чисел.

![image](https://user-images.githubusercontent.com/75197752/151578171-65bcb6ea-8946-4efa-bb1f-24fdfb6ab03f.png)

Общий алгоритм быстрой сортировки:
#### Сортировка стека А.
2. Находи опорный элемент.
3. В А оставляем элементы больше опорного, все элементы меньше опорного отправляются в В.
4. Сортируем А.
5. Сортируем В.
6. Конец.

#### Сортировка стека В.
2. Если стек отсортирован в убывающем порядке, то отпраляем числа в А, далее пункт 7. Иначе переходим к пункту 3.
3. Находи опорный элемент.
4. Оставляем элементы меньше опорного, все элементы больше опорного отправляются в А.
5. Сортируем А.
6. Сортируем В.
7. Конец.

Рассмотри более подробно.

Будем собирать отсортированные элементы в стеке А, для этого надо добавлять в его элементы в обратном порядке от наибольшего к наименьшему. Для этого все элементы меньше опорного отправляются в В, в А мы оставляем те элементы, которые больше опорного

![image](https://user-images.githubusercontent.com/75197752/151578894-01ad4c23-1797-412e-a65d-1dd712bdd41d.png)

В самой первой версии этого алгоритма я сортировал сначала стек В, собирая числа в убывающем порядке, а после перекидывал все в А. Это лишние N операций - сначала рекурсивно сортируем стек А, а после стек В.

![image](https://user-images.githubusercontent.com/75197752/151581292-29215bb7-8b64-4350-9431-ec05cdbad3b5.png)

![2022-01-28_19-09-53](https://user-images.githubusercontent.com/75197752/151585205-b1d7cd7c-4c90-4305-84ba-575913615ae2.png)

Пусть мы дошли до того момента, кода у нас отсортирован стек А. Сейчас там находятся наибольшие элементы набора. 

Теперь сортируем стек В. На этом моменте видно важное условие алгоритма, которую требуется соблюдать - надо поддерживать порядок элементов в стеках, чтобы не перемешать числа разных наборов. Потому что постоянно будет происходить такая ситуация при проходе по стеку А или В.

![image](https://user-images.githubusercontent.com/75197752/151590007-9e1bef6a-b16c-4531-b814-0f234b6e5130.png)

Соответственно надо каждый раз возвращать эти элементы на вершину, используя операции reverse rotate A/B.

Продолжаем сортировку до победного конца.

![image](https://user-images.githubusercontent.com/75197752/151590536-54da2a6e-65e0-4a03-a8eb-3d79064f3c63.png)
![image](https://user-images.githubusercontent.com/75197752/151590724-a677bb17-36da-45b6-bc7d-9def9fe4b00c.png)
![image](https://user-images.githubusercontent.com/75197752/151590826-9ca0ba92-4892-4336-980f-603503f0c774.png)
![image](https://user-images.githubusercontent.com/75197752/151590991-c9455299-428a-478f-8373-b3d313c0fa67.png)
![image](https://user-images.githubusercontent.com/75197752/151591094-2023d4b3-c499-42b8-9ea5-c052b6ad8128.png)
![image](https://user-images.githubusercontent.com/75197752/151591252-9416baee-3e9d-4cab-be3e-46be249d8026.png)

 voilà 

## Опорный элемент
При использовании алгоритма быстрой сортировки встает вопрос выбора опорного эелемента на каждом этапе сортировки. Лучшим опорным эелементом для выбора считается тот, который разделит набор на две равные или почти равные части. Есть несколько вариантов решения задачи.
#### 1. Вершина стека
Самый простой способ, но, очевидно, не самый лучший, потому что, если на вершине будет стоять число близкое к минимальному или максимальному, то разбиение будет неудачным.
#### 2. Среднее минимального и максимального элемента
Этот способ хорош при использовании на наборах, где числа распределены равномерно на отрезке [min, max].
Если набор будет выглядеть так:

1, -1, 0, 5, 100,

то разбиение будет неудачным.
#### 3. Один из трех
Выбираем вершину стека, конец стека, середину стека и находим средний из них. Остается шанс выбрать элемент близкий к минимальному или максимальному.
#### 4. Поиск точной середины
Поскольку в проекте учитывается только количество операций, применнённых к стеку, то можно сколь угодно долго анализировать стек для выбора лучшего опорного элемента.
Поэтому мною был выбран этот способ. Для упрощения поиска сопоставим каждому элементу его порядковый номер в отсортированном стеке. При сортировке группы элементов найдем максимальный и минимальный индекс, сложим и поделим целочисленно на 2. Это будет индекс опорного элемента.


## Пример
Пусть дан все тот же набор чисел.

![image](https://user-images.githubusercontent.com/75197752/151566312-5d251261-e584-4880-87dd-88e476363f17.png)

![image](https://user-images.githubusercontent.com/75197752/151567225-798bb589-fea9-431f-b0de-fd2755217c76.png)

Находим максимальный и минмальный индексы в стеке и делим целочисленно на 2: (7 + 0) / 2 = 3 -> -1 опорный элемент

![image](https://user-images.githubusercontent.com/75197752/151594329-2427b999-53ef-4968-b199-533328da39e3.png)

ra, ra, ra, ra, pb, pb, pb, rra, rra, rra, rra, rra


